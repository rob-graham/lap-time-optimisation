from __future__ import annotations

"""Command line interface for method B lap-time optimisation.

This script mirrors the interface of the existing Method A runner and
serves as an entry point for running the collocation-based solver via
``python -m run_method_b``.
"""

from pathlib import Path
import argparse
import json
from typing import Tuple, Optional

import numpy as np

from src.io_utils import read_track_csv, read_bike_params_csv
from src.geometry import load_track_layout
from src.method_b import ocp, solver, post


def run(
    track_csv: str,
    bike_csv: str,
    ds: float,
    *,
    closed: bool | None = None,
    closed_loop: bool = True,
    kappa_bounds: Tuple[float, float] = (-0.2, 0.2),
    u_kappa_bounds: Tuple[float, float] = (-0.1, 0.1),
    tol: float = 1e-8,
    print_level: int = 0,
    linear_solver: str = "mumps",
    ipopt_opts: Optional[dict] = None,
    warm_start: str | None = None,
    use_slacks: bool = False,
    auto_slack_retry: bool = True,
) -> Path:
    """Solve the lap-time optimisation problem using Method B.

    Parameters
    ----------
    track_csv, bike_csv:
        Input CSV files describing the track layout and bike parameters.
    ds:
        Arc-length spacing used to discretise the track.
    closed:
        Whether the track should be treated as a closed loop. ``None`` attempts
        to infer this from the CSV data.
    closed_loop:
        If ``True`` enforce periodic state continuity. Otherwise the initial
        state is fixed to zero and the terminal state is free.
    kappa_bounds, u_kappa_bounds:
        Bounds on the curvature state and rate control.
    tol, print_level, linear_solver, ipopt_opts:
        IPOPT solver configuration.
    warm_start:
        Optional path to warm-start data generated by Method A.
    use_slacks, auto_slack_retry:
        Control the inclusion of slack variables in the NLP formulation.
    """

    df = read_track_csv(track_csv)
    if closed is None:
        start = df[["x_m", "y_m"]].iloc[0].to_numpy()
        end = df[["x_m", "y_m"]].iloc[-1].to_numpy()
        closed = np.allclose(start, end, atol=1e-6)

    geom = load_track_layout(track_csv, ds, closed=closed)
    bike_params = read_bike_params_csv(bike_csv)

    centre = np.column_stack((geom.x, geom.y))
    left_dist = np.linalg.norm(geom.left_edge - centre, axis=1)
    right_dist = np.linalg.norm(geom.right_edge - centre, axis=1)
    track_half_width = float(np.min(np.minimum(left_dist, right_dist)))

    kappa_c = float(np.mean(geom.curvature))

    ocp_def = ocp.OCP(
        kappa_c=kappa_c,
        track_half_width=track_half_width,
        mu=float(bike_params.get("mu", 1.0)),
        a_wheelie_max=float(bike_params.get("a_wheelie_max", 9.81)),
        a_brake=float(bike_params.get("a_brake", 9.81)),
        power=float(bike_params.get("power", 100000.0)),
        mass=float(bike_params.get("mass", 200.0)),
        rho=float(bike_params.get("rho", 1.225)),
        CdA=float(bike_params.get("CdA", 0.5)),
        Crr=float(bike_params.get("Crr", 0.015)),
        phi_max_deg=float(bike_params["phi_max_deg"]) if "phi_max_deg" in bike_params else None,
        kappa_bounds=kappa_bounds,
        u_kappa_bounds=u_kappa_bounds,
    )

    s_start = 0.0
    s_end = ds * (geom.x.size - 1)
    n_points = geom.x.size

    warm_start_path = Path(warm_start) if warm_start else None

    result = solver.solve(
        ocp_def,
        s_start,
        s_end,
        n_points,
        closed_loop=closed_loop,
        warm_start_from_method_a=warm_start_path is not None,
        warm_start_file=warm_start_path,
        use_slacks=use_slacks,
        auto_slack_retry=auto_slack_retry,
        tol=tol,
        print_level=print_level,
        linear_solver=linear_solver,
        ipopt_opts=ipopt_opts,
    )

    out_dir = post.save_outputs(result)
    return out_dir


def main(argv: list[str] | None = None) -> None:
    parser = argparse.ArgumentParser(description="Run Method B lap-time optimisation")
    parser.add_argument("track_csv", help="Track layout CSV")
    parser.add_argument("bike_csv", help="Bike parameter CSV")
    parser.add_argument("--ds", type=float, default=1.0, help="Track discretisation spacing")
    group = parser.add_mutually_exclusive_group()
    group.add_argument("--open", dest="closed", action="store_const", const=False, help="Treat track as open")
    group.add_argument("--closed", dest="closed", action="store_const", const=True, help="Treat track as closed")
    parser.set_defaults(closed=None)
    parser.add_argument("--kappa-min", type=float, default=-0.2, help="Minimum curvature state")
    parser.add_argument("--kappa-max", type=float, default=0.2, help="Maximum curvature state")
    parser.add_argument("--u-kappa-min", type=float, default=-0.1, help="Minimum curvature rate")
    parser.add_argument("--u-kappa-max", type=float, default=0.1, help="Maximum curvature rate")
    parser.add_argument("--tol", type=float, default=1e-8, help="IPOPT solver tolerance")
    parser.add_argument("--print-level", type=int, default=0, help="IPOPT print level")
    parser.add_argument("--linear-solver", default="mumps", help="IPOPT linear solver")
    parser.add_argument("--ipopt-opts", type=str, default=None, help="Additional IPOPT options as JSON string")
    parser.add_argument("--warm-start", type=str, default=None, help="Warm start data from Method A")
    parser.add_argument("--use-slacks", action="store_true", help="Include slack variables from the start")
    parser.add_argument("--no-auto-slack", dest="auto_slack_retry", action="store_false", help="Disable automatic slack retry")
    parser.add_argument(
        "--closed_loop",
        action=argparse.BooleanOptionalAction,
        default=True,
        help="Enforce periodic state continuity",
    )

    args = parser.parse_args(argv)
    ipopt_opts = json.loads(args.ipopt_opts) if args.ipopt_opts else None

    out_dir = run(
        args.track_csv,
        args.bike_csv,
        args.ds,
        closed=args.closed,
        kappa_bounds=(args.kappa_min, args.kappa_max),
        u_kappa_bounds=(args.u_kappa_min, args.u_kappa_max),
        tol=args.tol,
        print_level=args.print_level,
        linear_solver=args.linear_solver,
        ipopt_opts=ipopt_opts,
        warm_start=args.warm_start,
        use_slacks=args.use_slacks,
        auto_slack_retry=args.auto_slack_retry,
        closed_loop=args.closed_loop,
    )
    print(f"Outputs written to {out_dir}")


if __name__ == "__main__":  # pragma: no cover - CLI entry point
    main()
